classdef  RandMPChan < matlab.System
    % RandMPChan:  Random multi-path channel 
    %
    % The channel impulse response is of the form:
    %
    %     h(t) = \sum_k sqrt(g(k))*exp(1i*theta(k))*delta(t-dly(k))
    %
    % The path gains are generated by first computing un-normalized
    % log normal values:
    %
    %    g0(k) = d2bpow( v(k) ),  v(k) ~N(0, gainStd^2)
    %
    % The values are then normalized to
    %
    %    g(k) = d2pow( gainTot )*g0(k) / sum(g0(k))
    %
    % so that gainTot is the total wideband gain.  The phases
    % theta(k) ~ U[0,2*pi].  The delays are distributed as:
    %
    %   dly(k) = dly0 + u(k),
    % 
    % dly0 is U[dlyInitRange(1), dlyInitRange(2)] and u(k) is exponential 
    % with mean excessDlyMean.
    properties
        % Channel generation properties      
        npath;         % number of paths    
        gainStd;       % std dev of path gains in dB
        gainTot;       % total gain of paths in dB
        dlyInitRange;      % min and max delay in seconds of first path
        excessDlyMean; % excess delay in seconds
        wvar;          % noise variance                
        fsamp;         % sample rate in Hz
        filLen;        % fractional delay filter length

        % Generated path parameters
        dly;    % path delays in seconds
        phase;  % phase in radians
        gain;   % channel gain in dB

        % Number of output samples.  Signal will be zero-padded
        % if needed.  A value of zero indicates not to fix the output
        % size
        nsampOut;
    end

    methods
        function obj = RandMPChan(opt)
            % Constructor
            %
            % Input parameters
            % ----------------
            % dlyInitRange: Range of delays for first path in seconds
            % excessDlyMean:  Mean delay of paths of initial paths
            % npath:  number of paths
            % gainStd:  std deviation of each path in dB
            % gainTot:  wideband gain in dB
            % fsamp:  Sampe frequency in Hz
            % wvar:  noise variance in linear scale
            % filLen:  Filter length in samples for fractional delays

            arguments
                opt.wvar   (1,1) {mustBeNumeric} = 0;
                opt.dlyInitRange (1,2) {mustBeNumeric} = [0,100e-6];
                opt.excessDlyMean (1,1) {mustBeNumeric} = 50e-9;
                opt.fsamp (1,1) {mustBeNumeric} = 40e6;
                opt.gainStd (1,1) {mustBeNumeric} = 8;
                opt.gainTot (1,1) {mustBeNumeric} = 0;
                opt.npath (1,1) {mustBeInteger} = 20;
                opt.nsampOut (1,1) {mustBeInteger} = 0;
                opt.filLen (1,1) {mustBeInteger} = 32;
            end

            % Save the parameters
            obj.wvar = opt.wvar;
            obj.dlyInitRange = opt.dlyInitRange;
            obj.fsamp = opt.fsamp;
            obj.gainStd = opt.gainStd;
            obj.gainTot = opt.gainTot;
            obj.npath = opt.npath;
            obj.nsampOut = opt.nsampOut;
            obj.excessDlyMean = opt.excessDlyMean;
            obj.filLen = opt.filLen;

        end

        function genPath(obj)            
            % Get random delay of first path
            dly0 = unifrnd(obj.dlyInitRange(1), obj.dlyInitRange(2), 1);

            % Generate random delays of other paths
            obj.dly = dly0 + exprnd(obj.excessDlyMean, obj.npath,1);

            % Generate random gains before normalization 
            obj.gain = obj.gainStd*randn(obj.npath,1);

            % Normalize to unit gain
            gainLin = db2pow(obj.gain);
            gainLin = gainLin / sum(gainLin);
            obj.gain = pow2db(gainLin) + obj.gainTot;

            % Generate random phases
            obj.phase = rand(obj.npath,1)*2*pi;
        end



        function r = dlySingPath(obj,x,gain,dly)
            % dlySingPath:  Simulates a single path channel with a delay in
            % and gain.

            % Find integer and fractional component of the delay
            dly = dly*obj.fsamp;
            dly1 = mod(dly,1);
            dly0 = round(dly-dly1);

            % Filter the fractional delay component
            nfilt = obj.filLen;
            tfilt = (-nfilt:nfilt)';
            h = sinc(tfilt + dly1);
            y = conv(h,x);

            % Shift signal by fractional component
            i0 = dly0-nfilt;
            ny = length(y);
            r = zeros(obj.nsampOut,1);
            i1 = min(i0+ny-1, obj.nsampOut);
            r(i0:i1) = db2mag(gain)*y(1:i1-i0+1);

        end
    end

    methods (Access = protected)

        function r = stepImpl(obj,x)
            % Runs the time-domain x through the channel
    
            % Compute the number of output samples
            dlySamp = ceil(max(obj.dly)*obj.fsamp) + obj.filLen;
            obj.nsampOut = dlySamp + length(x);

            % Loop over paths
            r = zeros(obj.nsampOut,1);
            for ipath = 1:obj.npath
                ri = obj.dlySingPath(x,obj.gain(ipath),obj.dly(ipath));
                r = r + ri;
            end

            % Add noise
            w = sqrt(obj.wvar/2)*(randn(obj.nsampOut,1) + 1i*randn(obj.nsampOut,1));
            r = r + w;
        end
    end

end

